1. Μεταφέραμε τα structs του Νίκου. 
2. Μεταφέραμε το IndexNode και το indexArray στο hash_file.h για να το βλέπει και το sht_file.c.
3. Προσθέσαμε στο IndexNode το πεδίο filename που κρατάει το όνομα του αρχείου. Το μέγεθος του πεδίου γίνεται defined σε 30.
4. Στην SHT_CreateSecondaryIndex βάλαμε έλεγχο για την ύπαρξη του αρχείου πρωτεύοντος ευρετηρίου που δίνεται από την παράμετρο char *fileName.
5. Προσθέθηκε στο SecHashHeader το πεδίο attribute (cities or surnames).



Δευτέρα 3 Ιανουαρίου 2022

1. H HT_InsertEntry δουλεύει
2. Στην HT_InsertEntry
    
    -Διόρθωση: Παίρναμε τα δεδομένα για το updateArray από record.city και record.surname, και είχε κάθε αλλαγή την ίδια πόλη και επίθετο αφού record είναι η εγγραφή που εισάγουμε. Έγινε αλλάγή σε entry.record[i].city (.surname αντίστοιχα) όπου entry.record[i] η τρέχουσα εγγραφή από την παλιά κατάσταση που εξετάζουμε κάθε φορά στην σχετική επανάληψη.

    -Διόρθωση: Δεν κάνουμε malloc μεσα στην συνάρτηση (άρα και δεν θα κάνουμε free στην SHT_Update) επειδή περνάμε δείκτη σε αντικείμενα (πίνακα)UpdateRecordArray, και όχι δείκτη σε αντίστοιχο πίνακα. Πέταγε seg fault όταν ζητούσαμε τα δεδομένα του updateArray. H malloc (ή γενικά η δέσμευση μνήμης - τώρα ορίζουμε πίνακα με στατικό μεγεθος στην ht_main) πρέπει να γίνεται στην συνάρτηση που κάνει declare το updateArray.

3. Δημιουργία printUpdateArray για εκτύπωση σχετικού πίνακα
4. define το μέγιστο αριθμό εγγραφών σε μπλοκ στο hash_file.h (ΜΑΧ_RECORDS)
5.  Στην main καθε φορά πριν εισάγουμε εγγραφή, το oldTupleId του πρώτου στοιχείου του πίνακα update, το αρχικοποιούμε σε 0 (που δεν έχει νόημα αφού    
    block_num >= 0 => tid > 1) και εξετάζουμε αν άλλαξε ώστε να μην παρατηρούμε πως αλλάζει το update όταν γίνονται αλλαγές μόνο.